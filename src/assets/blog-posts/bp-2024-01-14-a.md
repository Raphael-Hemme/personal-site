### Context
Some time between summer and fall of last year (2023), I had the idea to write a small Node script that would read out the markdown files in my blog and io-garden directories one by one and create an index of the words used. The individual words should then be assigned the path to the respective source files and the line numbers. Finally the resulting index object should be written to a json file on a specified path which I could then use as a simple search index on my personal site to offer not just the ability to retrieve relevant posts and io-garden experiments by activating a tag of interest but to also make them fully searchable by just entering a word or a word fragment into a search field.

I approached this little side project as an interesting learning opportunity - fully aware that it would be just a very simple solution to a problem that is addressed by people with Phd's in Math or Computer Science for decades and that my approach would most likely be technically anything but optimal. Yet, I liked it. Not at least because it gave me the opportunity to re-engage with Node. Furthermore I intended to use this project as a point of entry into search where I intentionally ignored existing solutions and best practices in a first step to actually make some of the mistakes that generations of programmers before me already made to better understand the solutions they came up with when, in a later stage, I would study how search was usually implemented by the community today. This is, why I called my project: '(The) Naive Search Preprocessor' or 'TNSP' in short.

### Current state of the project
As you read this, the current version of TNSP plus some frontend logic to handle search input and displaying the results is powering the search on my site and you can try it out which I am really happy about.

The whole code including some preliminary ideosyncrasies can be found on [GitHub](https://github.com/Raphael-Hemme/naive-search-preprocessor). The code is not yet documented but I will do so in the future. For now, I will just give a short overview of the current state of the project and how it works.

The current implementation of TNSP is a Node script that is run from the command line and generates the index as a local json file which can then be included in the project. The script takes a multiple arguments that specify the source paths and the output path and file name. 
A full command to run the script could look like this: `node index.js --source ./blog-posts ./io-garden-experiment-descriptions --target ./index.json`.
If the user did not specify the source and target paths as arguments to the command, the script will enter a CLI mode where the user is prompted for the paths. I developed the script to be run automatically in a pre commit hook or GitHub action or something similar where the arguments could be hard coded in the call to the script. The CLI mode is just a fallback for testing purposes and also to tinker with writing a Node CLI.

### Future directions
Since the size of the output file (the search index json file) is currently about 1mb which in my opinion is a bit to large to send it over the wire, and since the generation of the index is quite fast (at least running the current implementation on my machine), I'm considering re-implementing it client-side. In that case the index could be generated on demand or pre-generated when everything else on the root path is loaded and then stored in memory (inside an Angular service or proper state management system like NGRX or NGXS). The downside to this solution is that the user's machine will be hit with a processing spike instead of a spike in network traffic and that it necessitates to previously load all the markdown files. Currently the combined size of the markdown files (excluding this one) is just about 160kb - so considerably less than the search index (1mb). This would be a plus for the client-side generation approach at the moment. Should I magically increase my output in the future though - which I don't think is very likely -, this advantage would most likely turn into a disadvantage since I expect the size of the search index to increase logarithmically (? -> an initially steep curve that flattens out at some point) while the combined size of the markdown files should increase more or less linear with the addition of each file.
In short: I'm not sure which approach is better here but I think I'll give the client-side solution a try some time. Also, my current evaluation could be changed when studying existing search solutions or maybe there is a way to compress or encode the index in a more efficient way. In any case, I'm looking forward to more tinkering and learning with this project and hope you also get something from reading it.

### How it works
... coming soon.

#### index.ts - current implementation: 14.01.2024
```typescript
import {
    tap,
    of,
    from,
    map,
    switchMap,
    Subject,
    takeUntil
 } from 'rxjs';


import {
  printFrontMatter,
  printFilePaths,
  printHelp,
  printError,
  printPreprocessingFilesMsg,
  printProcessingMsg,
  printRemovingDuplicatesMsg
} from './cli-output.js';

import {
    reduceToUniqueKeys,
    removeDuplicateValueObjs,
    sortFinalIndexArr,
    SearchIndexEntryArrFormat,
    SearchIndexObj,
    FileContentObj,
    generateArrOfPreIndexObjsFromFilePathArr
} from './data-processing.js';

import { 
  generateFilePathArr,
  generateFileContentObjArr,
  writeSearchIndexObjToJsonFile
 } from './read-write-files.js';

import { processArgsAndExecuteMode, UserInputResultObj } from './cli-input.js';

let sourcePaths: string[] = [];
let targetPath: string = '';

const stopSignal$$ = new Subject();




const handleResultOfUserInput = (userInputResultObj: UserInputResultObj) => {
  if (userInputResultObj.mode === 'HELP') {
    printHelp();
    stopSignal$$.next('STOP');
  } else if (userInputResultObj.mode === 'ERROR') {
    printError(userInputResultObj.errors.join('\n'));
    stopSignal$$.next('STOP');
  } else {
    sourcePaths = userInputResultObj.sourcePaths.slice();
    targetPath = userInputResultObj.targetPath;
  }
};

/**
 * Sorts the cleaned pre-object array and writes the resulting search index to a JSON file.
 * @param cleanedPreObjArr - The cleaned pre-object array to sort and write to a JSON file.
 */
const sortAndWriteIndex = (cleanedPreObjArr: SearchIndexEntryArrFormat[]) => {
  const sortedCleanedPreObjArr: SearchIndexEntryArrFormat[] = sortFinalIndexArr(cleanedPreObjArr);

  const indexArr: SearchIndexObj[] = sortedCleanedPreObjArr.map((el: SearchIndexEntryArrFormat) => {
    return {
      searchTerm: el[0],
      searchResults: el[1]
    };
  });

  writeSearchIndexObjToJsonFile(indexArr, targetPath);
  stopSignal$$.next('STOP');
};

const main = () => {
  of('START')
    .pipe(
      takeUntil(stopSignal$$),
      tap(() => printFrontMatter()),
      switchMap(() => from(processArgsAndExecuteMode())),
      tap((userInputResultObj: UserInputResultObj) => handleResultOfUserInput(userInputResultObj)),
      map(() => generateFilePathArr(sourcePaths)),
      tap((filePathArr: string[]) => printFilePaths(filePathArr)),
      map((filePathArr: string[]): FileContentObj[] => generateFileContentObjArr(filePathArr)),
      map((fileContentArr: FileContentObj[]) => {
        printPreprocessingFilesMsg();
        return generateArrOfPreIndexObjsFromFilePathArr(fileContentArr);
      }),
      map((preIndexObjArr) => {
        printProcessingMsg();
        return reduceToUniqueKeys(preIndexObjArr, true);
      }),
      map((uniqueKeysArr) => {
        printRemovingDuplicatesMsg();
        return removeDuplicateValueObjs(uniqueKeysArr);
      }),
      tap((cleanedPreObjArr: SearchIndexEntryArrFormat[]): void => sortAndWriteIndex(cleanedPreObjArr))
    )
    .subscribe();
}

main();
```

#### cli-input.ts - current implementation: 14.01.2024
```typescript
import process from 'process';
import readline from 'readline';


export type Mode = 'CLI' | 'AUTO' | 'HELP' | 'ERROR'; 

export interface UserInputResultObj {
    sourcePaths: string[];
    targetPath: string;
    errors: string[];
    mode: Mode;
}


const getRelevantScriptArgs = (): string[] | null => {
    const args = process.argv.slice(2);
    if (args.length < 1) {
        console.log('You did not specify any source paths or a target file. Entering CLI mode.');
        return null;
    }
    return args;
}

const selectMode = (allArgs: string[] | null): Mode => {
    if (!allArgs) {
        return 'CLI';
    } 
    
    if (allArgs.includes('--help')) {
        return 'HELP';
    }

    if (allArgs.includes('--source') && allArgs.includes('--target')) {
        return 'AUTO';
    } else if (allArgs.includes('--source') || allArgs.includes('--target')) {
        return 'CLI';
    } else {
        return 'ERROR';
    };
}

const extractSourceAndTargetPathsFromArgs = (allArgs: string[] | null, mode: Mode): UserInputResultObj => {
    const resultObj: UserInputResultObj = {
        sourcePaths: [],
        targetPath: '',
        errors: [],
        mode: mode,
    }

    if (!allArgs) {
        return resultObj;
    }

    if (mode === 'HELP') {
        resultObj.mode = 'HELP';
        return resultObj;
    }

    let sourcePathsStartIndicator = allArgs.findIndex(arg => arg === '--source');
    let targetPathsStartIndicator = allArgs.findIndex(arg => arg === '--target');

    if (sourcePathsStartIndicator !== -1 && targetPathsStartIndicator !== -1) {
        resultObj.sourcePaths = allArgs.slice(sourcePathsStartIndicator + 1, targetPathsStartIndicator);
        resultObj.targetPath = allArgs[targetPathsStartIndicator + 1];

        if (resultObj.sourcePaths.length < 1) {
            resultObj.errors.push('missing source paths');
        }
        if (resultObj.targetPath === '') {
            resultObj.errors.push('missing target path');
        }

        if (resultObj.sourcePaths.length > 0 && resultObj.targetPath !== '') {
            resultObj.mode = 'AUTO';
        } else {
            resultObj.mode = 'CLI';
        }

    } else if (sourcePathsStartIndicator !== -1 && targetPathsStartIndicator === -1) {
        resultObj.sourcePaths = allArgs.slice(sourcePathsStartIndicator + 1);
        resultObj.errors.push('missing target path');
        resultObj.mode = 'CLI';
    } else if (sourcePathsStartIndicator === -1 && targetPathsStartIndicator !== -1) {
        resultObj.targetPath = allArgs[targetPathsStartIndicator + 1];
        resultObj.errors.push('missing source paths');
        resultObj.mode = 'CLI';
    } else {
        resultObj.errors.push('missing source paths');
        resultObj.errors.push('missing target path');
        resultObj.mode = 'CLI';
    }

    return resultObj;
}

const promptForSourcePaths = async (): Promise<string[]> => {
    const sourcePaths: string[] = [];
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    console.log('Please enter the paths to the source files you want to index. Enter "done" when you are finished.');
    while (true) {
        const answer = await new Promise<string>(resolve => rl.question('', resolve));
        if (answer === 'done') {
            rl.close();
            break;
        }
        sourcePaths.push(answer);
    }

    if (sourcePaths.length < 1) {
        console.log('You did not specify any source paths.');
        return await promptForSourcePaths();
    } else {
        return sourcePaths;
    }
}

const promptForTargetPath = async (): Promise<string> => {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    console.log('Please enter the path to the target file.');
    const answer = await new Promise<string>(resolve => rl.question('', resolve));
    rl.close();

    if (answer === '') {
        console.log('You did not specify a target path.');
        return await promptForTargetPath();
    } else {
        return answer;
    }

}

export const processArgsAndExecuteMode = async (): Promise<UserInputResultObj> => {

    const args = getRelevantScriptArgs();
    const mode = selectMode(args);
    const resultObj: UserInputResultObj = extractSourceAndTargetPathsFromArgs(args, mode);

    if (mode === 'CLI') {
        if (resultObj.sourcePaths.length < 1) {
            resultObj.sourcePaths = await promptForSourcePaths();
            if (resultObj.sourcePaths) {
                resultObj.errors = resultObj.errors.filter(error => error !== 'missing source paths');
            }
        }
        if (resultObj.targetPath === '') {
            resultObj.targetPath = await promptForTargetPath();
            if (resultObj.targetPath) {
                resultObj.errors = resultObj.errors.filter(error => error !== 'missing target path');
            }
        }
        console.log('Thanks for your input. Exiting CLI Mode. Starting indexing process now.');
        resultObj.mode = 'AUTO';

    } else if (mode === 'AUTO') {
        console.log('Entering AUTO Mode. Starting indexing process now.');
    } else if (mode === 'HELP') {
        console.log('Entering HELP Mode.');
    } else {
        console.log('Entering ERROR Mode.');
        resultObj.errors.push('Something went wrong. Please check your input and try again.');
    }

    return resultObj;
}
```

#### cli-output.ts - current implementation: 14.01.2024
```typescript
export const printFrontMatter = (): void => {
    console.log('\n')
    console.log('-- NAIVE SEARCH PREPROCESSOR --')
    console.log('\n')
};

export const printFilePaths = (filePathArr: string[]): void => {
    console.log('Found the following', filePathArr.length, 'files: ');
    for (const filePath of filePathArr) {
        console.log('\t', filePath);
    }
    console.log('\n')
};

export const printHelp = (): void => {
    console.log('To run the program in auto mode, use the following command:\n\n');
    console.log('\tnode index.js --source <source path> --target <target path>\n\n');
    console.log(`where <source path> is the path or a space separated list of paths to the directory / directories containing the files you want to index \nand <target path> is the path to the file you want to write the index to.\n`);

    console.log('To run the program in interactive mode / CLI mode, use the following command:\n\n');
    console.log('\tnode index.js\n');
    console.log('You will then be prompted to enter the paths to the source files and the target file.\n');

    console.log('To see this help text, use the following command:\n\n');
    console.log('\tnode index.js --help\n');
};

export const printError = (err: string): void => {
    console.log('There has been an error: ', err);
    console.log('\n');
};

export const printPreprocessingFilesMsg = (): void => {
    console.log('\n\nProcessing content of files...');
};

export const printProcessingMsg = (): void => {
    console.log('\n\nProcessing full indexes and collecting sources...');
    console.log('This might take a while. Thanks for your patience.');
};

export const printRemovingDuplicatesMsg = (): void => {
    console.log('\n\nRemoving duplicate matches...');
    console.log('Almost done now.\n\n');
};

export const printResultOfWritingFile = (err?: Error | null): void => {
    if (err) {
        console.log('There has been an error while writing the index to the file: ', err);
        console.log('\n');
    } else {
        console.log('Content has been written to file.\n');
    }
}
```

#### data-processing.ts - current implementation: 14.01.2024
```typescript
export interface LineSplitObj {
    line: number;
    contentArr: string[];
}

export interface SourceEntryObj {
    file: string;
    line: number;
}

export interface FileContentObj {
    fileContent: string;
    filePath: string;
}

export type SearchIndexEntryArrFormat = [string, SourceEntryObj[]];

export interface SearchIndexEntryObjFormat {
    [key: string]: SourceEntryObj[];
}

export interface SearchIndexObj {
    searchTerm: string;
    searchResults: SourceEntryObj[];
}



const matchSymbolsRegEx = /[^a-zA-Z0-9. ]/g;
const matchMultipleSpaceRegEx = /\s{2,}/g;
const matchMultipleDotRegEx = /\.{2,}/g;
const cleanSearchEntryStrRegEx = /[^a-zA-Z0-9]/g;




// currently not used - but might be useful later
const generatePartialEntries = (entry: string): string[] => {
    const partialsArr = [];
    for (let strLen = entry.length; strLen > 0; strLen--) {
        partialsArr.push(entry.slice(0, strLen));
    };
    return (partialsArr);
}


/**
 * Cleans up a string by replacing symbols with spaces, removing extra spaces, and trimming the result.
 * @param {string} lineStr - The string to clean up.
 * @returns {string} The cleaned up string.
 */
export const cleanUpLineStr = (lineStr: string): string => {
    return lineStr
        .replace(matchSymbolsRegEx, ' ')
        .replace(matchMultipleSpaceRegEx, ' ')
        .trim();
}

/**
 * Generates an array of objects, each representing a line of text with its line number and the lines content split into an array of cleaned words.
 * @param {string} data - The input string to be processed.
 * @returns {LineSplitObj[]} An array of objects, each containing the line number and an array of cleaned words.
 */
export const generateCleanedLineSplitArr = (data: string): LineSplitObj[] => {
    let i = 1;
    const newLineSplitArr = data.split('\n').map(l => {
      const cleanedLineStr = cleanUpLineStr(l);
      const cleanedLineStrArr = cleanedLineStr.split(' ');
  
      const result = {
        line: i,
        contentArr: cleanedLineStrArr
      }
  
      i += 1;
      return result;
    });
  
    return newLineSplitArr;
}

/**
 * Cleans a search entry string by replacing multiple dots with a single dot, removing any trailing or leading punctuation, and converting to lowercase.
 * @param {string} searchEntryStr - The search entry string to be cleaned.
 * @returns {string} The cleaned search entry string.
 */
export const cleanSearchEntryStr = (searchEntryStr: string): string => {
    const strLen = searchEntryStr.length;
    let cleanedStr = searchEntryStr.replace(matchMultipleDotRegEx, '.');

    if (cleanSearchEntryStrRegEx.test(searchEntryStr[strLen - 1])) {
        cleanedStr = searchEntryStr.slice(0, strLen - 2);
    } else if (cleanSearchEntryStrRegEx.test(searchEntryStr[0])) {
        cleanedStr = searchEntryStr.slice(1);
    } else {
        cleanedStr = searchEntryStr;
    }

    return cleanedStr.toLowerCase();
}

export const generatePreIndexObjArr = (
    cleanedLineSplitArr: LineSplitObj[],
    sourceFilePath: string
): SearchIndexEntryArrFormat[] => {
    const indexArr: SearchIndexEntryArrFormat[] = [];
    for (const lineObj of cleanedLineSplitArr) {
        for (const contentE of lineObj.contentArr) {
            /*
             * Push the content entry into the index array - itself formatted as an array of the string (the key) and an array
             * with one object as its only entry that contains the source file and line number. Putting this source object
             * into an arry will help later when filtering for duplicate string entries (keys) - which will become the search keys
             * in an index object. Because we can't have identical keys, we need to reduce all identical keys over all file
             * arrays and push the source objects into an array so each key can have multiple matching sources. 
             */
            indexArr.push(
                [
                    cleanSearchEntryStr(contentE),
                    [
                        {
                            file: sourceFilePath,
                            line: lineObj.line
                        }
                    ]
                ]
            );
        }
    }

    // delete entries with emty strings (can happen when multiple space characters follow in a row and space is used as seperator)
    const cleanedIndexArr = indexArr.filter(el => el[0]);
    const reducedArr = reduceToUniqueKeys(cleanedIndexArr);

    return reducedArr;
}

/**
 * Reduces an array of SearchIndexEntryArrFormat objects to an array of unique keys and their corresponding values.
 * @param {SearchIndexEntryArrFormat[]} inputArr - The input array to be processed.
 * @param {boolean} [isFullArr=false] - A boolean indicating whether the input array contains full arrays or sub-arrays.
 * @returns {SearchIndexEntryArrFormat[]} An array of unique keys and their corresponding values.
 */
export const reduceToUniqueKeys = (inputArr: SearchIndexEntryArrFormat[], isFullArr: boolean = false): SearchIndexEntryArrFormat[] => {
    let reducedArr = [];
    for (const preIndexArr of inputArr) {
        const duplicateKeyEntrysArr = inputArr.filter(el => el[0] === preIndexArr[0]);
        const subArrToPush = duplicateKeyEntrysArr.map(el => isFullArr ? el[1] : el[1].flat()).flat();
        if (duplicateKeyEntrysArr.length > 0) {
            reducedArr.push([
                preIndexArr[0],
                subArrToPush
            ]);
        } else {
            reducedArr.push(preIndexArr);
        }
    }

    const stringifiedArr = reducedArr.map(el => JSON.stringify(el))
    const reducedStringifiedArr = Array.from(new Set(stringifiedArr))
    reducedArr = reducedStringifiedArr.map(el => JSON.parse(el));

    return reducedArr;
};

export const generateArrOfPreIndexObjsFromFilePathArr = (fileContentArr: FileContentObj[]): SearchIndexEntryArrFormat[] => {
    const resultArr: SearchIndexEntryArrFormat[] = [];
    for (const file of fileContentArr) {
        const cleanedLineSplitArr = generateCleanedLineSplitArr(file.fileContent);
        resultArr.push(...generatePreIndexObjArr(cleanedLineSplitArr, file.filePath))
    }

    return resultArr;
}

/**
 * Removes duplicate objects from an array of SearchIndexEntryArrFormat objects.
 * @param {SearchIndexEntryArrFormat[]} inputArr - The input array to be processed.
 * @returns {SearchIndexEntryArrFormat[]} An array of SearchIndexEntryArrFormat objects with duplicate objects removed.
 */
export const removeDuplicateValueObjs = (inputArr: SearchIndexEntryArrFormat[]): SearchIndexEntryArrFormat[] => {
    return inputArr.map(el => {
        const stringifiedValueArr = el[1].map(e => JSON.stringify(e));
        const filteredValueArr = Array.from(new Set(stringifiedValueArr)).map(el => JSON.parse(el));
        return [
            el[0],
            filteredValueArr
        ];
    });
};

/**
 * Sorts an array of SearchIndexEntryArrFormat objects by the first element of each sub-array.
 * @param {SearchIndexEntryArrFormat[]} inputArr - The input array to be sorted.
 * @returns {SearchIndexEntryArrFormat[]} A sorted array of SearchIndexEntryArrFormat objects.
 */
export const sortFinalIndexArr = (inputArr: SearchIndexEntryArrFormat[]): SearchIndexEntryArrFormat[] => {
    const sortedArr = inputArr.sort((a, b) => {
        if (a[0] > b[0]) {
            return 1;
        } else if (a[0] < b[0]) {
            return -1
        } else {
            return 0;
        }
    });

    return sortedArr;
}
```

#### read-write-files.ts - current implementation: 14.01.2024
```typescript
import {
    readFileSync,
    readdirSync,
    writeFile 
} from 'fs';

import { printResultOfWritingFile } from './cli-output.js';

import { FileContentObj, SearchIndexObj } from './data-processing.js';

export const generateFilePathArr = (dirArr: string[]): string[] => {
    const fileNameArr: string[][] = [];
    for (const dir of dirArr) {
      const filesOfDirArrEntryArr = readdirSync(dir);
      for (const fileName of filesOfDirArrEntryArr) {
        fileNameArr.push([dir, fileName]);
      }
    }
    return fileNameArr.map(([dir, fileName]) => `${dir}/${fileName}`);
};

export const generateFileContentObjArr = (filePathArr: string[]): FileContentObj[] => {
    const fileContentArr: FileContentObj[] = [];
    console.log('Reading files:')
    for (const filePath of filePathArr) {
      fileContentArr.push({
        fileContent: readFileSync(filePath, 'utf8'),
        filePath
      })
    }
    return fileContentArr;
}

export const writeSearchIndexObjToJsonFile = (searchIndexArr: SearchIndexObj[], trgtP: string) => {
    const jsonObj = JSON.stringify(searchIndexArr);
    writeFile(trgtP, jsonObj, 'utf8', (err: Error | null): void => printResultOfWritingFile(err));
};
```
### Context
Last summer (2023), I had the idea to write a small Node.js script that would read out the markdown files in my blog and io-garden directories one by one and create an index of the words with references to all of their locations (the path to the source files and the corresponding line numbers). Finally the resulting index should be written to a json file under a specified path which I could then use as a simple search index on my personal site to offer not just the ability to retrieve relevant content by clicking on a tag of interest but to also make the content fully searchable by just entering a word or a word fragment into a search field.

> There are many terrible misakes to make in program design, and you should go ahead and make them so that you understand them. A sense of what a good program looks like is developed in practice, not learned from a list of rules.
<cite>(Haverbeke 2019: 3)</cite>

I approached this little side project as an interesting learning opportunity, well aware that it would be just a very simple solution to a complex problem addressed by experts in Math or Computer Science for decades. Yet, I liked the idea - not at least because it gave me the opportunity to re-engage with Node. Furthermore I intended to use this project as a point of entry into the domain of search and I intentionally ignored existing solutions and best practices in this first approach to actually make some of the same mistakes as generations of programmers before me because I believe that actually making some of those mistakes allows for a deeper understanding of the solutions they came up with. But of course in a later stage, I plan to study how search is usually implemented by the community today. This is not my go-to approach to learning about a new field btw and I wouldn't recommend it in many situations but I believe it can be worth a try in some. 
This intentional ignorance or naivitÃ© is, why I called my project: '(The) Naive Search Preprocessor' or 'TNSP' in short.

### Current state of the project
As you read this, the search on my site is powered by the current version of TNSP, enhanced with some frontend logic to manage search input and display results. I'm really happy about that and encourage you to give it a try.

The whole code including some preliminary idiosyncrasies can be found on [GitHub](https://github.com/Raphael-Hemme/naive-search-preprocessor). The code is not well documented yet but I'll work on that while writing a small series of posts about TNSP here. For now, I will just give a short overview of the current state of the project and how it works.

The current implementation of TNSP is a Node script that is run from the command line and generates the index as a local json file which can then be used in another place like my website as a search index. The script takes multiple arguments that specify the source paths and the output path + file name.

A full command to run the script could look like this: `node index.js --source ./dir-one ./dir-two --target ./index.json`.

The short form flags `-s` instead of `--source` and `-t` instead of `--target` do work as well and you can change the order of appearance.

If the user did not specify the source and target paths as arguments to the command, or if invalid paths are detected, the script will enter a CLI mode where the user is prompted to enter the missing or invalid paths.

I developed the script to be eventually run automatically in a pre-push hook or something similar where the arguments could be provided in advance in the call to the script. The CLI mode was initially just a fallback and also another opportunity to experiment with writing a Node CLI. But the CLI mode grew in scope and I enjoy working on it. Therefore I'm currently still adding small improvements or fix issues while executing the script manually. But the automation will be addressed and then also be documented in a blog post. 

### Future directions

#### Upcoming
I'm planning to work on the following issues, features etc. and document that work in the form of individual blogposts over the next weeks and months:

##### Try gzip compression
One of my highest priorities is to try gzipping the json output file to reduce its size. If the compression rate is satisfying, and the decompression on the client side does not require immense extra resources in the form of a library, I will implement it as the default behavior and also research and write about how this compression works.

##### Automatic execution
As mentioned earlier, I intend to use TNSP in an automatic style, where the script is executed before I push changes in my site's local repository to the remote on GitHub.
Ideally the script should only execute if one of the previously committed files is part of the source directories in order to prevent unnecessary processing and unnecessary commits if nothing has changed. On the other hand, unnecessary commits at least should not even be an issue since aside from metadata, the index should be identical after running the script on the same unchanged source files. ... Let's find out.

##### Testing
I want to add unit tests using Jest or Vitest. Ideally before the next point in this list.

##### Refactoring and adding JSDoc comments
Some of the functions and possibly the general data flow should be refactored and appropriate JSDoc comments added.

##### Various improvements (not in that order)
- Parsing of arguments - make it possible to also use the long form flags with equal signs
- Fancy CLI output during the processing stages
- Safeguards: Check if I can prevent the script from reading or writing from / to undesirable directories like `/` etc. which a user might enter by accident but be really mad about when files in these locations are read or overwritten
- Additional arguments / config to specify file types to be included in the indexing - e.g. only index `.md` files or only index `.js` and `.ts` files but not any other files in the source directories.
- improve tokenization in order to preserve more of the relevant information. Due to the crude RegEx approach I'm currently using, all special characters / symbols are removed and the tokens are also lowercased which prevents case sensitive search. But especially the removal of special characters is not ideal in the case of code snippets.
- ... to be continued

#### Prospects

##### Client side execution of TNSP
(-> depends on the outcome of the compression experiment - see above)

Since the size of the output file (the search index json file) is currently about 1.1mb which in my opinion is a bit too large to send it over the wire, and since the generation of the index is quite fast (at least running the current implementation on my machine), I'm considering re-implementing it client-side. In that case the index could be generated on demand or pre-generated when everything else on the root path is loaded and then stored in memory (inside an Angular service or proper state management system like NGRX or NGXS). The downsides to this solution are 1. that the user's machine will be hit with a processing spike instead of a spike in network traffic and 2. that it necessitates to previously load all the markdown files. Currently the combined size of the markdown files (excluding this one) is just about 160kb - so considerably less than the search index (~1100kb). This would be a plus for the client-side generation approach at the moment. Should I magically increase my output in the future though - which I don't think is very likely -, this advantage would most likely turn into a disadvantage since I expect the size of the search index to increase logarithmically (? -> an initially steep curve that flattens out at some point) while the combined size of the markdown files should increase more or less linear with the addition of each file.
In short: I'm not sure which approach is better here but I think I'll experiment with the client-side solution at some point. Also, my current evaluation could be changed when studying existing search solutions or maybe there is a way to compress or encode the index in a more efficient way. In any case, I'm looking forward to more tinkering and learning with this project and hope you find some joy in reading it.

##### Research and implement more advanced search solutions
This is a bit tricky because I definitely want to learn about and play with more advanced or at least more appropriate search algorithms and solutions while documenting this journey but at what point should I rename the project to "The Not-so-naive Search Preprocessor" and most importantly, how would anyone know since the acronym would still be TNSP... ;)
I think there is much room for improvement while still calling it naive. But let's just wait and see. :)

### How it works
#### Overview
The script is split into four modules: `tnsp.ts`, `file-io.ts`, `cli-io.ts` and `data-processing.ts`. While the script that is executed with node actually consists of the compiled JavaScript files, I'll talk about the TypeScript files here as if they were the actual script to make things easier. But keep in mind, that there is a compile step and the executed code is not the TS but the JS code.
The entry point of the program is `tnsp.ts` which executes a main function. This main function in turn starts a RxJS stream that uses mostly map operations inside a pipe to step by step handle the calls to functions from the other modules. 

1. The arguments from the node command are parsed in and checked for their validity and completeness or the presence of a special argument like `--help` to 
2. determine the current mode: 
  1. If a path to a provided source directory or the target for the final index file is invalid or if the user did not specify all of those arguments, the script enters a CLI mode to prompt the user for the missing or incorrect arguments until all needed information is present and valid.
  2. If the argument included `--help` or `-h`, the script will print a help message and exit.
  3. In case of an error (which should be handled by the CLI mode in the first place but I'm sure, I missed some potential issues like specific file types that can't be read etc.), the script will print an error message and exit.
  4. If the arguments are valid and complete or the user was already prompted during the CLI mode (Step 2.1) and entered valid source and target paths there, the script enters an automatic mode where the next steps are executed.
3. All source paths and the target paths should be valid at this point. Now the source files are read and the content is passed to
4. the date processing functions. Here the content of each file is split up into lines and then into words. The words are then tokenized and the tokens are stored in an array of objects with the word as the key and an array of references to the source file and the line number as the value. The array of objects is then reduced so that each token is only present once in the array and the references are combined into the source array on that token. A similar reducer is then applied to the array that combines the result from the last step over all the source files.
5. The resulting array of objects is finally written to a json file at the target path.

#### tnsp.ts
```typescript
import { 
  tap,
  of,
  from,
  map,
  switchMap,
  Subject,
  takeUntil,
  filter
} from "rxjs";

import {
  printFrontMatter,
  printFilePaths,
  printHelp,
  printError,
  printPreprocessingFilesMsg,
  printProcessingMsg,
  printRemovingDuplicatesMsg,
} from "./cli-io.js";

import {
  reduceToUniqueKeys,
  removeDuplicateValueObjs,
  sortCleanedIndexArr,
  SearchIndexEntryArr,
  FileContentObj,
  generateRawIndex,
  reformatIndex
} from "./data-processing.js";

import {
  generateFilePathArr,
  generateFileContentObjArr,
  writeSearchIndexObjToJsonFile,
} from "./file-io.js";

import { processArgsAndExecuteMode, UserInputResultObj } from "./cli-io.js";

let sourcePaths: string[] = [];
let targetPath: string = "";

const stopSignal$$ = new Subject();

const handleResultOfUserInput = (userInputResultObj: UserInputResultObj) => {
  if (userInputResultObj.mode === "HELP") {
    printHelp();
    stopSignal$$.next("STOP");
  } else if (userInputResultObj.mode === "ERROR") {
    printError(userInputResultObj.errors.join("\n"));
    stopSignal$$.next("STOP");
  } else {
    sourcePaths = userInputResultObj.sourcePaths.slice();
    targetPath = userInputResultObj.targetPath;
  }
};

const main = () => {
  of("START")
    .pipe(
      takeUntil(stopSignal$$),
      tap(() => printFrontMatter()),
      switchMap(() => from(processArgsAndExecuteMode())),
      tap((userInputResultObj: UserInputResultObj) =>
        handleResultOfUserInput(userInputResultObj)
      ),
      filter((userInputResultObj: UserInputResultObj) => {
        return userInputResultObj.mode === 'AUTO' 
          || userInputResultObj.mode === 'CLI'
      }),
      map(() => generateFilePathArr(sourcePaths)),
      tap((filePathArr: string[]) => printFilePaths(filePathArr)),
      map((filePathArr: string[]): FileContentObj[] =>
        generateFileContentObjArr(filePathArr)
      ),
      map((fileContentArr: FileContentObj[]): SearchIndexEntryArr[] => {
        printPreprocessingFilesMsg();
        return generateRawIndex(fileContentArr);
      }),
      map((preIndexObjArr): SearchIndexEntryArr[] => {
        printProcessingMsg();
        return reduceToUniqueKeys(preIndexObjArr, true);
      }),
      map((uniqueKeysArr): SearchIndexEntryArr[] => {
        printRemovingDuplicatesMsg();
        return removeDuplicateValueObjs(uniqueKeysArr);
      }),
      map((cleanedIndexArr: SearchIndexEntryArr[]): SearchIndexEntryArr[] => {
        return sortCleanedIndexArr(cleanedIndexArr)
      }),
      tap((cleanedAndSortedIndexArr: SearchIndexEntryArr[]): void => {
        const finalIndex = reformatIndex(cleanedAndSortedIndexArr);
        writeSearchIndexObjToJsonFile(finalIndex, targetPath);
        stopSignal$$.next("STOP");
      })
    )
    .subscribe();
};

main();

```

Let's go through the main function step by step:

In the first line of the function body `of("START")` creates a new RxJS Observable with the arbitrary string value of 'START'. 
This observable is then piped and finally subscribed to - at the end of the function body. The pipe consists of a series of operations that first substitue the arbitrary initial string value with actually meaningful values that are processed and transformed in each subsequent operation.

The first operator `takeUntil(stopSignal$$)` will simply stop the execution of the pipe when the `stopSignal$$` subject emits a value. `stopSignal$$` is created at the beginning of the script and is used to stop the execution of the script 
a. when an error occurs after printing the error,
b. when the user entered the help mode or
c. when the script successfully completed. 

The next operator is a `tap()` operator, because it executes a mere side effect without changing anything about the observable's value. The side effect of `tap(() => printFrontMatter())` is to print a welcome message to the terminal. 

Now, the actual data processing begins with the `switchMap()` operator. The line `switchMap(() => from(processArgsAndExecuteMode()))` 'switches' the RxJS stream from the initial observable with a value of 'START' to a new observable. This new observeable is generated by converting the return value of `processArgsAndExecuteMode` into an observable using `from()`. So, let's hop over to `cli-io.ts` and have a look at `processArgsAndExecuteMode` which parses the arguments from the command line, determines the mode of operation (CLI or AUTO) and returns an Object with the results of the user input.

```typescript
export const processArgsAndExecuteMode = async (): Promise<UserInputResultObj> => {

  const args = getRelevantScriptArgs();
  const mode = selectMode(args);
  const resultObj: UserInputResultObj = extractSourceAndTargetPathsFromArgs(args, mode);

  switch (resultObj.mode) {
    case 'CLI':
      stdout.write('-- Entering CLI mode.\n\n');
      return await executeCLIMode(resultObj);
    case 'AUTO':
      stdout.write('-- Entering AUTO mode. Starting indexing process now.\n\n');
      return resultObj;
    case 'HELP':
      stdout.write('-- Entering HELP mode.\n\n');
      return resultObj;
    case 'ERROR': // fallthrough
    default:
      stdout.write('-- Entering ERROR mode.\n\n');
      resultObj.errors.unshift('Something went wrong. Please check your input and try again.\n');
      return resultObj;
  }
}
```

As you can see, `processArgsAndExecuteMode` calls a number of other functions to get the relevant arguments, determine the mode for the further execution of the script and extract the potentially provided source and target paths before it enters a switch statement that executes the appropriate mode.

The `selectMode` function is a remnant of previous versions and will be refactored in the future. Until then, it only checks if the user requested help, if all arguments are present and valid in order to enter the AUTO mode or if the script should enter the CLI mode.

```TypeScript
const getRelevantScriptArgs = (): string[] | null => {
  const args = argv.slice(2);
  if (args.length < 1) {
    stdout.write('You did not specify any source paths or a target file. Entering CLI mode. \n');
    return null;
  }
  return args;
}
```

The `extractSourceAndTargetPathsFromArgs` function is a bit more complex. Let's have a look at it:

```TypeScript
const extractSourceAndTargetPathsFromArgs = (
  allArgs: string[] | null, 
  mode: Mode
): UserInputResultObj => {

  const resultObj: UserInputResultObj = {
    sourcePaths: [],
    targetPath: '',
    errors: [],
    mode: mode,
  }

  if (!allArgs) {
    resultObj.errors.push('missing source paths');
    resultObj.errors.push('missing target path');
    resultObj.mode = 'CLI';
    return resultObj;
  }

  if (mode === 'HELP') {
    resultObj.mode = 'HELP';
    return resultObj;
  }

  let sourcePathsArr = extractAndCheckSourceOrTargetPathsFromArgs(allArgs, 'source', 'target');
  let invalidSourcePaths = sourcePathsArr.filter(pathObj => !pathObj.isValid);
  let targetPathsArr = extractAndCheckSourceOrTargetPathsFromArgs(allArgs, 'target', 'source');

  if (sourcePathsArr.length === 0) {
    resultObj.errors.push('missing source paths');
  }

  if (invalidSourcePaths.length > 0) {
    resultObj.errors.push('invalid source paths');
  }

  if (targetPathsArr.length === 0) {
    resultObj.errors.push('missing target path');
  }

  if (targetPathsArr.length > 0 && !targetPathsArr[0].isValid) {
    resultObj.errors.push('invalid target path');
  }

  
  if (resultObj.errors.length === 0) {
    resultObj.sourcePaths = sourcePathsArr.map(pathObj => pathObj.path);
    resultObj.targetPath = targetPathsArr[0].path;
    resultObj.mode = 'AUTO';
  } else {
    resultObj.sourcePaths = sourcePathsArr.map(pathObj => pathObj.path);
    resultObj.targetPath = targetPathsArr[0]?.path ?? [];
    resultObj.mode = 'CLI';
  }
  
  return resultObj;
}
```



Let's for now ignore the `CLI`, `HELP` and `ERROR` modes and focus on the `AUTO` mode.


The `tap((userInputResultObj: UserInputResultObj) => handleResultOfUserInput(userInputResultObj))` operator will call the `handleResultOfUserInput` function which will handle the result of the `processArgsAndExecuteMode` function. 

The `filter((userInputResultObj: UserInputResultObj) => { return userInputResultObj.mode === 'AUTO' || userInputResultObj.mode === 'CLI' })` operator will filter out the results that are not in AUTO or CLI mode. 

The `map(() => generateFilePathArr(sourcePaths))` operator will call the `generateFilePathArr` function which will generate an array of file paths from the source paths provided by the user. 

The `tap((filePathArr: string[]) => printFilePaths(filePathArr))` operator will call the `printFilePaths` function which will print the file paths to the console. 

The `map((filePathArr: string[]): FileContentObj[] => generateFileContentObjArr(filePathArr))` operator will call the `generateFileContentObjArr` function which will generate an array of file content objects from the file paths. 

The `map((fileContentArr: FileContentObj[]): SearchIndexEntryArr[] => { printPreprocessingFilesMsg(); return generateRawIndex(fileContentArr); })` operator will call the `generateRawIndex` function which will generate a raw index from the file content objects.

The `map((preIndexObjArr): SearchIndexEntryArr[] => { printProcessingMsg(); return reduceToUniqueKeys(preIndexObjArr, true); })` operator will call the `reduceToUniqueKeys` function which will reduce the raw index to unique keys.

The `map((uniqueKeysArr): SearchIndexEntryArr[] => { printRemovingDuplicatesMsg(); return removeDuplicateValueObjs(uniqueKeysArr); })` operator will call the `removeDuplicateValueObjs` function which will remove duplicate value objects from the unique keys array.

The `map((cleanedIndexArr: SearchIndexEntryArr[]): SearchIndexEntryArr[] => { return sortCleanedIndexArr(cleanedIndexArr) })` operator will call the `sortCleanedIndexArr` function which will sort the cleaned index array.

The `tap((cleanedAndSortedIndexArr: SearchIndexEntryArr[]): void => { const finalIndex = reformatIndex(cleanedAndSortedIndexArr); writeSearchIndexObjToJsonFile(finalIndex, targetPath); stopSignal$$.next("STOP"); })` operator will call the `reformatIndex` function which will reformat the cleaned and sorted index array and then write the search index object to a JSON file.

At the end of the file the `main` function is called to start the execution of the script, when the the user runs the script with `node tnsp.js`.



### References
<sub>
**Haverbeke, Marijn**  
**2019**  Eloquent JavaScript. 3rd Edition.
<sub>